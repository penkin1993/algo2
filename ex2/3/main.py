"""
C. Выбор вершин дерева
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Дан граф, являющийся деревом. Необходимо найти размер наибольшего по мощности независимого множества. Множество вершин графа называется независимым, если никакие две вершины этого множества не соединены ребром.

Входные данные
Граф в этой задаче задан в виде корневого дерева. В графе выделена вершина — корень дерева. Для каждой вершины i, не являющейся корнем, задан номер вершины-предка pi в корневом дереве. Дерево, заданное таким образом, состоит из рёбер i—pi для всех вершин i, кроме корня.

В первой строке входного файла записано целое число n — количество вершин в графе (1 ≤ n ≤ 100). В следующих n строках задан граф. В i-й из этих строк записано целое число pi — номер вершины-предка i-й вершины. Для корня дерева pi = 0; для всех остальных вершин 1 ≤ pi ≤ n.

Гарантируется, что заданный во входном файле граф является деревом.
"""

import sys

from collections import defaultdict


def dfs(top, dp_0, dp_1):
    [dfs(child, dp_0, dp_1) for child in graph_structure[top]]

    dp_0[top] += sum([max(dp_0[child], dp_1[child]) for child in graph_structure[top]])
    dp_1[top] += sum([dp_0[child] for child in graph_structure[top]])


n = int(sys.stdin.readline())
graph_structure = defaultdict(list)

for i in range(1, n + 1):
    edge = int(sys.stdin.readline())
    if edge != 0:
        graph_structure[edge].append(i)
    else:
        root = i

dp_0 = defaultdict(lambda: 0)  # если не храним текущую врешину
dp_1 = defaultdict(lambda: 1)  # если храним текущую врешину

dfs(root, dp_0, dp_1)

print(max(dp_0[root], dp_1[root]))
